module Base do
  @doc "Core Rascal syntax."

  # try/catch/finally error handling idiom.
  mac raise(exc_type::Symbol) do
    @doc "Simplest case."
    quote, do: perform {[:exception, unquote(exc_type)]}
  end

  mac raise(args::Tuple{Symbol, ..}) do
    @doc "More complex: tuple of arguments passed."
    quote, do: perform {[:exception, unquote(fst(args))], splice(rst(args))}
  end

  mac raise(args::Tuple{List, ..}) do
    @doc "More complex yet: tuple of arguments passed, exception type namespaced."
    quote, do: perform {[:exception, splice(fst(args))], splice(rst(args))}
  end

  mac try(do: try_block, catch: catch_block) do
    @doc "Most complex macro in try/catch/finally probably?"

    fun expand_catch_clause(clause) do
      stx clause do
       e -> ..b            => [:exception, e]          -> ..b
       [..e] -> ..b        => [:exception, ..e]        -> ..b
       {e, ..a} -> ..b     => {[:exception, e], ..a}   -> ..b
       {[..e], ..a} -> ..b => {[:exception, ..e], ..a} -> ..b
       _                   => syntax_error(clause, &env, "Bad catch clause.")
      end
    end

    quote do
      begin do
        splice(try_block)
      handle
        splice(map(expand_catch_clause, catch_block))
      end
    end
  end
end

module Enum do
  @doc "Iteration and enumeration utilities."
  fun empty?(xs::List),  do: xs == []
  fun empty?(xs::Tuple), do: xs == ()
  fun empty?(xs::Map),   do: xs == {}
  fun empty?(xs::Bits),  do: xs == <<>>

  fun map(fn::Function, xs::List) do
    loop(xs::List = xs, accum::List = []) do
      case xs do
        []     -> reverse(accum)
        [x|xs] -> loop(xs, fn(x) | accum)
      end
    end
  end

  fun map(fn::Function, kvs::Map) do
    loop(kvs::Map, accum::Map = {}) do
      case kvs do
        {}             -> accum
        {k => v | kvs} -> loop(kvs, k => fn(v) | accum)
      end
    end
  end

  fun map(fn::Function, bs::Bits) do
    loop(bs::Bits, accum::Bits = <<>>) do
      case bs do
      <<>>         -> reverse(accum)
      <<b | bs>>   -> loop(bs, fn(b) | accum)
    end
  end

  fun filter(p?::Function, xs::List) do
    loop(xs::List = xs, accum::List = []) do
      case xs do
        []      -> reverse(accum)
        [x|xs]  -> if p?(x), do: loop(xs, x|accum), else: loop(xs, accum)
      end
    end
  end

  fun fold(fn::Function{A, A, B}, xs::List{A}) :: B do
    case xs do
      []     -> raise :value_error, "fold() called on empty list with no initializer supplied."
      [x|xs] -> fold(fn, xs, x)
    end
  end

  fun fold(fn::Function{A, A, B}, xs::List{A}, acc::B) :: B do
    case xs do
      []     -> acc
      [x|xs] -> fold(fn, xs, fn(acc, x))
    end
  end
end

module Math do
  @doc "Various utilities to flesh out the standard library."

  # Specialized numeric types.
  union Integer, do: Big | Small
  
  struct Ratio do
    numer::Integer
    denom::Integer
  end

  union Rational, do: Integer | Ratio

  struct Complex do
    real::Number
    imag::Number
  end

  union Number, do: Real | Big | Small | Ratio | Complex

  # Basic value tests.
  fun zero?(x::Number), do: x == 0
  fun one?(x::Number),  do: x == 1
  fun even?(x::Integer), do: zero?(x % 2)
  fun odd?(x::Integer),  do: one?(x % 2)

  fun divides?(a::Integer, b::Integer) do
    b % a == 0
  end

  # Absolute value function.
  fun abs(x::Number) do
    if x < 0 do
      -x
    else
      x
    end
  end

  # Common operations.
  fun sqr(x::Number), do: x * x
  fun cub(x::Number), do: x * x * x
  fun inc(x::Number), do: x + 1
  fun dec(x::Number), do: x - 1

  # Standard fast power algorithm (tail recursive).
  fun pow(x::Number, n::Number) do
    loop(x::Number = x, n::Number = n, acc::Number = 1) do
      if n == 0 do
        acc
      elif even?(n)
        loop(x*x, n/2, acc)
      else
        loop(x, n-1, x*acc)
      end
    end
  end

  # Euclid's algorithm.
  fun gcd(a::Integer, b::Integer) do
    if b > a do
      gcd(b, a)
    elif divides?(b, a)
      b
    else
      gcd(b, a % b)
    end
  end

  # Numerical derivative.
  fun diff(x::Number, fx::Function, h::Number = 1e-10) do
    fx(x + h) - fx(x) |>  &(&1 / h)
  end

  # Newton's method.
  fun sqrt(a::Number, h::Number = 1e-10) do
    loop(x::Number = a) do
      if abs(sqr(x) - a) <= h do
        x
      else
        loop(x - sqr(x) / diff(x, sqr, h))
      end
    end
  end

  # Operations on collections.
  fun sum(xs::List),   do: fold('+, xs, 0)
  fun prod(xs::List),  do: fold('*, xs, 1)
  fun hypot(xs::List), do: map(sqr, xs) |> sum |> sqrt

  fun mean(xs::List{Number}) do
    if empty?(xs) do
      0
    else
      sum(xs) / length(xs)
    end
  end
end
