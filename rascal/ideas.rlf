# This file is for experimenting with different syntaxes and shouldn't be expected to work.

# By default, annotations are attached to the current environment. This will be the module environment at toplevel.

provide Ideas
require Core, Base, "local.rlf"

@doc "Syntax experiments and demonstrations."

type Numeric # example abstract type

type Int32 = Small # example type alias

type Number = Real | Small | Big | Ratio | Complex # example union type

type Gender = :Male | :Female | :Other # example enum type

type Person = {name: Str, age: Int, gender: Gender} # example record type

type Pair = (car: Any, cdr: Any) # example struct type

# example of algebraic type definitions
type EmptyCons = () # creates new singleton type
type ConsNode = (head: Any, tail: ConsNode | EmptyCons)
type Cons = EmptyCons | ConsNode

# overloading methods for the new type
fun size(_: EmptyCons) = 0

fun size(n: ConsNode) do
  loop n = n, acc = 0 do
    case n do
      ()     -> acc
      (_, t) -> loop t, acc+1
    end
  end
end

# Example of how trait types could work (obviously a lot of this could be abstracted out with macros but that's not a priority right now)
type Sequence # Create new abstract type

fun declare_sequence(t: Type) do # Create a method for 
  cache = put_meta!(Sequence, :instance_cache, {})
  cache = map_set(cache, t, true)
  set_meta!(Sequence, :instance_cache, cache)
end

fun isa?(x, t :: Sequence) do # define an interface
  X = typeof(x)
  cache = put_meta!(t, :instance_cache, {})
  answer = get(cache, XType, nul)

  if answer == nul do
    answer = method_exists(seq, (X,)) and
             method_exists(first, (X,)) and
             method_exists(rest, (X,))

    cache = map_set(cache, X, answer)

    set_meta!(t, :instance_cache, cache)
  end

  answer
end



fun seq(_: EmptyCons) = nul
fun seq(n: ConsNode) = n
fun first(_: EmptyCons) = nul
fun first(n: ConsNode) = n.head
fun rest(_: EmptyCons) = nul
fun rest(n: ConsNode) = if t == EmptyCons(), do: nul, else: n.tail

# Effect examples

fun with_output_file(path, handler) do
  @doc "Example of basic effect usage."

  control do
    in = open(path); handler(in)

  handle
    (:error.file_not_found, _, _) ->
      print("file not found at '#{path}'.")
      close(in)
      nul

    (:error.* as err, [msg], _) ->
      close(in)
      raise err, [msg]

    (op, args, k) ->
      raise op, args, k
  end
end

# Example of building simple control structures with effects and macros
fun qualify_exception(exc_type) do
  if is_sym?(exc_type) do
    if not has_ns?(exc_type, :error) do
      qualify(:error, exc_type)
    else
      exc_type
    end
  else
    [:error.*, :as, exc_type]
  end
end

mac throw(exc_type) do
  throw(exc_type, "error")
end
  
mac throw(exc_type, msg) do
  op = qualify_exception(exc_type)

  quote do
    raise $(op), [$(msg)]
  end
end

mac try(do: body, catch: handlers) do
  
  fun xform(name_pattern, msg_pattern) do
    op = qualify_exception(name_pattern)

    quote do
      ( $$(op), [$(msg_pattern)], _ )
    end
  end

    xformed_handlers = transform_patterns(handlers)

    quote do
      control do
        $$(body)

      handle
        $$(xformed_handlers)

        (op$, args$, k$) ->
          raise op$, args$, k$
      end
    end
  end

  fun with_output_file(path: Str, handler: Fun) do
    try do
      in = open(path)
      out = handler(in)
      close(in)
      out

    catch
      (:file_not_found, _) ->
        print("No file at '#{path}'.")
        close(in)
        nul

      (exc, msg) ->
        close(in)
        throw exc, msg
    end
  end

  # Example of more complex control structures built with effects and macros
  mac yield(x) do
    quote do
      raise :generator.yield, [$(x)]
    end
  end

  mac yield(x, to: thread) do
    quote do
      raise :generator.yield, [$(x), $(thread)]
    end
  end

mac coro(args, do: body) do
  quote do
    
  end
end

mac coro(name, args, do: body) do
  quote do
    $(name) = make_coro(fun($(args), $(body)))
  end
end

  fun make_coro(fn: Fun) do
    fun wrapper(args...) do
      mut resume = nul

      fun inner(args...) do
        if resume != nul do
          resume(args...)
        else
          control do
            fn(args...)

          handle
            (:generator.yield, [x], k) ->
              resume = k
              x

            (:generator.yield, [x, t], k) ->
              resume = k
              t(x)

            (op, args, k) ->
              raise op, args, k
          end
        end
      end

      inner(args...)
    end

    wrapper
  end

coro range(start, stop, step) do
  loop start = start, stop = stop, step = step do
    if start >= stop do
      stop
    else
      yield start
      loop start+step, stop, step
    end
  end
end
