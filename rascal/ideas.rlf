# This file is for experimenting with different syntaxes and shouldn't be expected to work.

# By default, annotations are attached to the current environment. This will be the module environment at toplevel.

provide Ideas
require Core, Base, "local.rlf"

@doc "Syntax experiments and demonstrations."

type Numeric # example abstract type

type Int32 = Small # example type alias

type Number = Real | Small | Big | Ratio | Complex # example union type

type Gender = :Male | :Female | :Other # example enum type

type Person = {name: Str, age: Int, gender: Gender} # example record type

type Pair = (car: Any, cdr: Any) # example struct type

# example of algebraic type definitions
type EmptyCons = () # creates new singleton type
type ConsNode = (head: Any, tail: ConsNode | EmptyCons)
type Cons = EmptyCons | ConsNode

# overloading methods for the new type
fun size(_: EmptyCons) = 0

fun size(n: ConsNode) do
  loop n = n, acc = 0 do
    case n do
      ()     -> acc
      (_, t) -> loop t, acc+1
    end
  end
end

# Example of how trait types could work (obviously a lot of this could be abstracted out with macros but that's not a priority right now)
type Sequence # Create new abstract type

fun declare_sequence(t: Type) do # Create a method for adding members
  cache = put_meta!(Sequence, :instance_cache, {})
  cache = map_set(cache, t, true)
  set_meta!(Sequence, :instance_cache, cache)
end

fun isa?(x, t :: Sequence) do # define an interface
  X = typeof(x)
  cache = put_meta!(t, :instance_cache, {})
  answer = get(cache, XType, nul)

  if answer == nul do
    answer = method_exists?(seq, (X,)) and
             method_exists?(first, (X,)) and
             method_exists?(rest, (X,))

    cache = map_set(cache, X, answer)

    set_meta!(t, :instance_cache, cache)
  end

  answer
end

# Define for new type
fun seq(_: EmptyCons) = nul
fun seq(n: ConsNode) = n
fun first(_: EmptyCons) = nul
fun first(n: ConsNode) = n.head
fun rest(_: EmptyCons) = nul
fun rest(n: ConsNode) = if n.tail == EmptyCons(), do: nul, else: n.tail

declare_sequence(Cons)
declare_sequence(EmptyCons)
declare_sequence(ConsNode)

# Effect examples
fun with_output_file(path, handler) do
  @doc "Example of basic effect usage."

  control do
    in = open(path); handler(in)

  handle
    (:error.file_not_found, _, _) ->
      print("file not found at '#{path}'.")
      close(in)
      nul

    (:error.* as err, [msg], _) ->
      close(in)
      raise err, [msg]

    (op, args, k) ->
      raise op, args, k
  end
end

# Example of building simple control structures with effects and macros
fun qualify_exception(exc_type) do
  if is_sym?(exc_type) do
    if not has_ns?(exc_type, :error) do
      qualify(:error, exc_type)
    else
      exc_type
    end
  else
    [:error.*, :as, exc_type]
  end
end

mac throw(exc_type) do
  throw(exc_type, "error")
end
  
mac throw(exc_type, msg) do
  op = qualify_exception(exc_type)

  quote do
    raise $(op), [$(msg)]
  end
end

mac try(do: body, catch: handlers) do
  
  fun xform(name_pattern, msg_pattern) do
    op = qualify_exception(name_pattern)

    quote do
      ( $$(op), [$(msg_pattern)], _ )
    end
  end

    xformed_handlers = transform_patterns(handlers)

    quote do
      control do
        $$(body)

      handle
        $$(xformed_handlers)

        ($op, $args, $k) ->
          raise $op, $args, $k
      end
    end
  end

  fun with_output_file(path: Str, handler: Fun) do
    try do
      in = open(path)
      out = handler(in)
      close(in)
      out

    catch
      (:file_not_found, _) ->
        print("No file at '#{path}'.")
        close(in)
        nul

      (exc, msg) ->
        close(in)
        throw exc, msg
    end
  end

# Example of implementing a new feature using effects, macros, and overloading
mut type Coro = (done?, result, resume, fn)

fun Coro(fn: Fun) do
  fun wrapper(coro, fn) do
    fun (args...) do
      control do
        coro.result = fn(args...)
        coro.done? = true
        coro.resume = nul

      handle
        (:coro.yield, [x], k) ->
          coro.resume = k
          x

        (op, args, k) ->
          raise op, args, k
      end 
    end
  end

  coro = Coro(false, nul, nul, nul)
  coro.fn = wrapper(coro, fn)
  coro
end

fun call(fn: Coro, args...) do
  if coro.done? do
    coro.result
  elif coro.resume == nul
    coro.fn(args...)
  else
    coro.resume(args...)
  end
end

mac yield(x) do
  quote do
    raise :generator.yield, [$(x)]
  end
end
