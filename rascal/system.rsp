;;; begin system.rsp

;;; some initial utilities
(fun zero? "x is zero?"
  (x) (= x 0))

(fun one? "x is one?"
  (x) (= x 1))

(fun =?
  "equal?"
  (x y)
  (zero? (ord x y)))

;;; basic type tests and whatnot
(fun nil?   (x) (id? x nil))
(fun true?  (x) (id? x true))
(fun false? (x) (id? x false))
(fun eos?   (x) (id? x eos))

(fun cons? (x) (isa? x cons))
(fun sym?  (x) (isa? x sym))
(fun str?  (x) (isa? x str))
(fun func? (x) (isa? x func))
(fun real? (x) (isa? x real))
(fun chr?  (x) (isa? x chr))
(fun bool? (x) (isa? x bool))
(fun port? (x) (isa? x port))

;;; first real test of multiple dispatch
(fun len
  ((nil x)) 0)

(fun len
  ((cons xs))
  (:len xs))

(fun len
  ((str xs))
  (:len xs))

;;; first real test of algebraic effects
(cntl exception
  (raise x))

;;; first real test of macros
(mac catch
  (handlers . actions)
  `(with ~handlers
     	 (fun ()
	      (do ~@actions))))

;;; a simple function combining all 3
(fun parity
  (xs ys)
  (catch ((raise x)
  	  (if (=? x :zero-div)
	      0
	      (raise x)))
	 (/ (len xs)
	    (len ys))))

;;; basic type definitions
(union list
       (nil cons))

(union num
       (real int))

(union seq
       (list str))

(union atom
       (not cons))

;; list and sequence utilities
(fun list
  (.. args) args)

(fun empty?
  ((seq xs))
  (zero? (len xs)))

(fun len=?
  (xs i)
  (= (len xs) i))

(fun nth
  ((nil xs) _)
  (raise :bounds-error))

(fun nth
  ((cons xs) (int n))
  (cond ((zero? n) (car xs))
  	(otherwise (nth (cdr xs)
		   	(dec n)))))

(fun nth
  ((str xs) (int n))
  (ref xs n))

(fun str->list
  ((str xs))
  (str->list xs 0))

(fun str->list
  ((str xs) (int i))
  (cond ((len=? xs i) ())
  	(otherwise    (cons (ref xs i)
		      	    (str->list xs (inc i))))))

(fun list->str
  ((list xs))
  (apply str list))

;;; apply specializations
(fun map
  (fn (list xs))
  (cond ((nil? xs) ())
  	(otherwise (cons (fn (car xs))
		   	 (map fn (cdr xs))))))

(fun map
  (fn (str xs))
  (list->str (map fn (str->list xs))))

;;; end system.rsp