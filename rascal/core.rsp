;;; begin core.rsp
;;; rascal basics module.

;;; well-known value predicates
(fun nul?    (x) (id? x nul))
(fun any?    (x) true)
(fun none?   (x) false)
(fun eos?    (x) (id? x eos))
(fun true?   (x) (id? x true))
(fun false?  (x) (id? x false))

;;; builtin type predicates
(fun bool? (x) (isa? x bool))
(fun chr?  (x) (isa? x chr))
(fun int?  (x) (isa? x int))
(fun real? (x) (isa? x real))

(fun port? (x) (isa? x port))
(fun func? (x) (isa? x func))
(fun sym?  (x) (isa? x sym))
(fun cons? (x) (isa? x cons))
(fun vec?  (x) (isa? x vec))
(fun str?  (x) (isa? x str))
(fun set?  (x) (isa? x set))
(fun dict? (x) (isa? x dict))

;;; basic logic and comparison
(fun not (x) (if x true false))

;;; basic numeric definitions and utilities
(type num
      (union int real))

(fun zero? (x) (=? x 0))
(fun one?  (x) (=? x 1))

(fun inc ((n int)) (+ n 1))
(fun dec ((n int)) (- n 1))

(fun /= (x y) (not (= x y)))
(fun <= (x y) (or (< x y)
     	      	  (= x y)))
(fun >  (x y) (not (<= x y)))
(fun >= (x y) (not (< x y)))

(fun even? (n) (zero? (mod n 2)))
(fun odd?  (n) (one? (mod n 2)))

;;; basic higher order functions
(fun neg (fn)
  (fun args
    (not (fn . args))))

(fun curry (fn arg)
  (fun args
    (fn arg . args)))

(fun compose (f g)
  (fun args
    (f (g . args))))

;;; list implementation and basic utilities
(type list
      (union cons nul))

(fun list args args)

(fun cons* (x (cons xs)) (cons x xs))
(fun cons* (x y . more)  (cons x (cons* y . more)))

(fun copy ((xs list)) (apply list xs))

(fun cat ((xs list) (ys list))
  (if (nul? xs) ys
      otherwise (cons (hd xs)
      		      (cat (tl xs) ys))))

(fun rev ((xs list))
  (nrev (copy xs)))

;;; preferred list accessors
(fun hd ((cons x)) (car x))
(fun tl ((cons x)) (cdr x))
(fun hd ((nul x))  nul)
(fun tl ((nul x))  nul)

;;; hd/tl compositions
(fun ttl (x) (tl:tl x))
(fun thd (x) (tl:hd x))
(fun htl (x) (hd:tl x))
(fun hhd (x) (hd:hd x))

(fun tttl (x) (tl:tl:tl x))
(fun tthd (x) (tl:tl:hd x))
(fun thtl (x) (tl:hd:tl x))
(fun thhd (x) (tl:hd:hd x))
(fun httl (x) (hd:tl:tl x))
(fun hthd (x) (hd:tl:hd x))
(fun hhtl (x) (hd:hd:tl x))
(fun hhhd (x) (hd:hd:hd x))

(fun ttttl (x) (tl:tl:tl:tl x))
(fun ttthd (x) (tl:tl:tl:hd x))
(fun tthtl (x) (tl:tl:hd:tl x))
(fun tthhd (x) (tl:tl:hd:hd x))
(fun thttl (x) (tl:hd:tl:tl x))
(fun ththd (x) (tl:hd:tl:hd x))
(fun thhtl (x) (tl:hd:hd:tl x))
(fun thhhd (x) (tl:hd:hd:hd x))
(fun htttl (x) (hd:tl:tl:tl x))
(fun htthd (x) (hd:tl:tl:hd x))
(fun hthtl (x) (hd:tl:hd:tl x))
(fun hthhd (x) (hd:tl:hd:hd x))
(fun hhttl (x) (hd:hd:tl:tl x))
(fun hhthd (x) (hd:hd:tl:hd x))
(fun hhhtl (x) (hd:hd:hd:tl x))
(fun hhhhd (x) (hd:hd:hd:hd x))

(fun fst (x::cons) (hd x))
(fun snd (x::cons) (htl x))
(fun thd (x::cons) (httl x))
(fun fth (x::cons) (htttl x))

;;; basic sequence utilities
(fun len=?
  (xs (n int))
  (= (len xs) n))

(fun len=?
  (xs (n int) (k int) . more)
  (or (len=? xs n)
      (len=? k . more)))

(fun len>=?
  (xs (n int))
  (not (< n (len xs))))

(fun nth
  ((xs cons) (n int))
  (if (one? n)  (hd xs)
      otherwise (nth (tl xs)
      		     (dec n))))

(fun nth
  ((xs str) (n int))
  (str-ref xs n))

(fun nth
  ((xs vec) (n int))
  (vec-ref xs n))

(fun map
  (fn xs)
  (cond (nul? xs) ()
        otherwise (cons (fn xs)
                        (map fn (tl xs)))))

(fun filter
  (p? xs)
  (if (nul? xs)    ()
      (p? (hd xs)) (cons (hd xs)
      	      	   	 (filter p? (tl xs)))
      otherwise    (filter p? (tl xs))))

(fun reduce
  (fn (xs list))
  (reduce fn (tl xs) (hd xs)))

(fun reduce
  (fn (xs list) acc)
  (if (nul? xs) acc
      otherwise (reduce fn (tl xs)
      			   (fn acc (hd xs)))))

(fun take
  ((n int) xs)
  (if (zero? n) '()
      (nul? xs) '()
      otherwise  (cons (hd xs)
      		       (take (dec n)
		       	     (tl xs)))))

(fun take
  (p? xs)
  (if (nul? xs)    '()
      (p? (hd xs)) '()
      otherwise    (cons (hd xs)
      		   	 (take p? (tl xs)))))

(fun drop
  ((n int) xs)
  (if (zero? n) xs
      (nul? xs) '()
      otherwise (drop (dec n) (tl xs))))

(fun drop
  (p? xs)
  (if (nul? xs)  '()
      (p?|hd xs) (drop p? (tl xs))
      otherwise  xs))

(fun some?
  (p? xs::list)
  (if (nul? xs)    false
      (p?|hd xs)   true
      otherwise    (some? p? (tl xs))))

(fun every?::bool
  (p? xs::list)
  (if (nul? xs)    true
      (p?|hd xs)   (every? p? (tl xs))
      otherwise    false))

;;; eval and expand utilities (syntax checkers, etc)
(fun hd=? (xs) false)
(fun hd=? (xs x) (and (cons? xs) (=? (hd xs) x)))
(fun hd=? (xs x . more) (or (hd=? xs x)
     	      	  	    (hd=? xs . more)))

(fun atom? (x)
  (not (cons? x)))
;;; end core.rsp