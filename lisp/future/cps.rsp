;;; begin cps.rsp

(fun list? [x] (or x.cons? x.nil?))
(fun atom? [x] (not x.list?))

(mac form-predicate [name]
  `(fun ~(symbol (string* name "?"))
     [x]
     (and x.pair? (id? x.car '~name))))

(form-predicate if)
(form-predicate do)
(form-predicate fun)
(form-predicate and)
(form-predicate or)
(form-predicate mac)
(form-predicate :=)
(form-predicate fun/cc)

(fun do->cps [forms k]
  (cond (atom? forms)      `(~k ~forms)
        (null? forms.cdr)  (cps- forms.car k)
        else               (cps- forms.car
			   	 `(fun [~_#] ~(do->cps (cdr forms) k)))))

(mac fun/cc [args body]
  `(cons 'fun/cc (fun ~args ~body)))

; a utility used at run time to dispatch a call with or without
; the continuation argument~ depending on the function
(fun funcall/cc [f k & args]
  (if (fun/cc? f)
      (apply f.cdr (cons k args))
      (k (apply f args))))

(val *funcall/cc-names*
  (apply tuple
	 (map #(symbol (string 'funcall/cc- %1))
	      (iota 6))))

(mac [def-funcall/cc-n args]
  (let [name ((len args) *funcall/cc-names*)]
    `(fun ~name [f k ~@args]
       (if (fun/cc? f)
           (f.cdr k ~@args)
	   (k (f ~@args))))))

(def-funcall/cc-n ())
(def-funcall/cc-n (a0))
(def-funcall/cc-n (a0 a1))
(def-funcall/cc-n (a0 a1 a2))
(def-funcall/cc-n (a0 a1 a2 a3))
(def-funcall/cc-n (a0 a1 a2 a3 a4))

(fun rest->cps [xformer form k argsyms]
  (let [el (car form)]
    (if (or el.atom? el.constant?)
        (xformer form.cdr k (cons el argsyms))
        (let [g (symbol)]
        (cps- el `(fun (~g)
                    ~(xformer form.cdr k (cons g argsyms))))))))

(fun make-funcall/cc [head ke args]
  (let [n args.length]
    (if (< n 6)
        `(~(n *funcall/cc-names*) ~head ~ke ~@args)
        `(funcall/cc ~head ~ke ~@args))))

; (f x) => (cps- f `(lambda (F) ~(cps- x `(lambda (X) (F ~k X)))))
(fun app->cps [form k argsyms]
  (cond
    (atom? form) (let [r (rev argsyms)]
                   (make-funcall/cc r.car k r.cdrr)))
    else         (rest->cps app->cps form k argsyms))

; (+ x) => (cps- x `(lambda (X) (~k (+ X))))
(fun builtincall->cps [form k]
  (prim->cps form.cdr k (list form.car)))

(fun prim->cps [form k argsyms]
  (cond (atom? form) `(~k ~(reverse argsyms))
        else         (rest->cps prim->cps form k argsyms)))

(val *top-k* (symbol))
(:= *top-k* identity)

(fun cps [form]
  (η-reduce
   (β-reduce
    (expand
     (cps- (expand form) *top-k*)))))

(fun cps- [form k]
  (let [g (symbol)]
    (cond (or form.atom? form.constant?)
            `(~k ~form)
          (fun? form)
           `(~k (fun/cc (~g ~@form.cadr) ~(cps- form.caddr g)))
          (do? form)
           (do->cps form.cdr k)
          (if? form)
           (let [test form.cadr
                 then form.caddr
                 els  form.cadddr]
             (if (atom? k)
                 (cps- test
		       `(fun [~g]
		          (if ~g
                              ~(cps- then k)
                              ~(cps- els k))))
                 `(let [~g ~k]
                   ~(cps- form g))))
          (and? form)
           (cond (atom? form.cdr) `(~k true)
                 (atom? form.cddr) (cps- form.cadr k)
                 else              (if (atom? k)
                      		       (cps- form.cadr
                                             `(fun [~g]
                               		       (if ~g
					       	   ~(cps- `(and ~@form.cddr) k)
                                 	       	   (~k ~g)))
                    		       `(let [~g ~k]
                       		         ~(cps- form g)))))

          (or? form)
           (cond (atom? form.cdr)  `(~k false)
                 (atom? form.cddr) (cps- (cadr form) k)
                 else (if (atom? k)
                      	  (cps- form.cadr
                            `(fun [~g]
                               (if ~g
			       	   (~k ~g)
                                   ~(cps- `(or ~@form.cddr) k))))
                          `(let ((~g ~k))
                          ~(cps- form g))))

          ((id? (car form) ':=)
           (let ((var (cadr form))
                 (E   (caddr form)))
             (cps- E `(lambda (~g) (~k (set! ~var ~g))))))

          ((id? (car form) 'reset)
           `(~k ~(cps- (cadr form) *top-k*)))

          ((id? (car form) 'shift)
           (let ((v (cadr form))
                 (E (caddr form))
                 (val (symbol)))
             `(let ((~v (fun/cc (~g ~val) (~g (~k ~val)))))
                ~(cps- E *top-k*))))

          ((id? (car form) 'without-delimited-continuations)
           `(~k ~(cadr form)))

          ((and (constant? (car form))
                (builtin? (eval (car form))))
           (builtincall->cps form k))

          ; ((lambda (...) body) ...)
          ((and (pair? (car form))
                (id? (caar form) 'lambda))
           (let ((largs (cadr (car form)))
                 (lbody (caddr (car form))))
             (cond ((null? largs)   ; ((lambda () body))
                    (cps- lbody k))
                   ((symbol? largs) ; ((lambda x body) args...)
                    (cps- `((lambda (~largs) ~lbody) (list ~@(cdr form))) k))
                   (true
                    (cps- (cadr form) `(lambda (~(car largs))
                                         ~(cps- `((lambda ~(cdr largs) ~lbody)
                                                  ~@(cddr form))
                                                k)))))))

          (true
           (app->cps form k ())))))

; (lambda (args...) (f args...)) => f
; but only for constant~ builtin f
(fun (η-reduce form)
  (cond ((or (atom? form) (constant? form)) form)
        ((and (id? (car form) 'lambda)
              (let ((body (caddr form))
                    (args (cadr form)))
                (and (pair? body)
                     (equal? (cdr body) args)
                     (constant? (car (caddr form))))))
         (car (caddr form)))
        (true (map η-reduce form))))

(fun contains [x form]
  (or (id? form x)
      (any (lambda (p) (contains x p)) form)))

(fun β-reduce [form]
  (if (or (atom? form) (constant? form))
      form
      (β-reduce- (map β-reduce form))))

(fun (β-reduce- form)
        ; ((lambda (f) (f arg)) X) => (X arg)
  (cond ((and (length= form 2)
              (pair? (car form))
              (id? (caar form) 'lambda)
              (let ((args (cadr (car form)))
                    (body (caddr (car form))))
                (and (pair? body) (pair? args)
                     (length= body 2)
                     (length= args 1)
                     (id? (car body) (car args))
                     (not (id? (cadr body) (car args)))
                     (symbol? (cadr body)))))
         `(~(cadr form)
           ~(cadr (caddr (car form)))))

        ; (identity x) => x
        ((id? (car form) *top-k*)
         (cadr form))

        ; uncurry:
        ; ((lambda (p1) ((lambda (args...) body) exprs...)) s) =>
        ; ((lambda (p1 args...) body) s exprs...)
        ; where exprs... doesn't contain p1
        ((and (length= form 2)
              (pair? (car form))
              (id? (caar form) 'lambda)
              (or (atom? (cadr form)) (constant? (cadr form)))
              (let ((args (cadr (car form)))
                    (s (cadr form))
                    (body (caddr (car form))))
                (and (pair? args)
		     (length= args 1)
                     (pair? body)
                     (pair? (car body))
                     (id? (caar body) 'fun)
                     (let ((innerargs (cadr (car body)))
                           (innerbody (caddr (car body)))
                           (params (cdr body)))
                       (and (not (contains (car args) params))
                            `((lambda ~(cons (car args) innerargs)
                                ~innerbody)
                              ~s
                              ~@params)))))))

        (true form)))

(mac with-delimited-continuations [& code]
  (cps `((fun [] ~@code))))

; a test case

;;todo:
;;* tag lambdas that accept continuation arguments~ compile computed
;;  calls to calls to funcall/cc that does the right thing for both
;;  cc-lambdas and normal lambdas
;;
;;* handle dotted arglists in lambda
;;
;;- optimize constant functions~ e.g. (funcall/cc-0 #:g65 (lambda (#:g58) 'done))
;;
;;- implement CPS version of apply
;;
;;- use fewer symbols
;;
;; here's an alternate way to transform a while loop:
;;
;; (let ((x 0))
;;   (while (< x 10)
;;     (begin (print x) (set! x (+ 1 x)))))
;; =>
;;  (let ((x 0))
;;    (reset
;;     (let ((l false))
;;       (let ((k (shift k (k k))))
;;         (if (< x 10)
;;             (begin (set! l (begin (print x)
;;                                   (set! x (+ 1 x))))
;;                    (k k))
;;           l)))))
;;
;; end cps.rsp