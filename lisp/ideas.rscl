# speculative non-lisp syntax.

module Core
  import Meta::(repr)

  @doc "Core Rascal syntax (imported automatically in most modules)."

  fun syntax_error(expr)
    raise error::syntax("Malformed expression: #{expr}.")
  end

  mac case(expr, block) do
  
    quote do
      let ($expr_name = $(expr)) do
        
      end
    end
  end

  mac var(expr) do
    case expr do
      [name] ->
        quote do
          def $(name) do
            @final false
            nul
          end
        end
      [:=, name, value] ->
        quote do
          def $(name) do
            @final false
            value
        end
      _ ->
        syntax_error("`var #{repr(expr)}`")
    end
  end

  mac val(expr) do
    case sexpr(expr) do
      [:=, name, value] ->
        quote do
          def $(name) do
            @final true
            value
          end
        end
      _ ->
        syntax_error("`val #{repr(expr)}`")
    end
  end
end

module Base
  import Core.*
  import Mutable.*

  @doc "Example code for notional Rascal base library (non-lisp variant)."

  # basic multimethod examples
  fun count(xs) do
    @doc "Return the number of elements in the sequence `xs`."
    raise error.method("No method matching signature (#{typeof xs}).")
  end

  fun count(xs: List) do
    list_count(xs)
  end

  fun count(xs: Map) do
    map_count(xs)
  end

  fun count(xs: Str) do
    str_count(xs)
  end

  fun count(xs: Bin) do
    bin_count(xs)
  end

  fun empty?(xs)
    @doc "Return `true` if the given collection has no more elements."
    count(xs) == 0
  end

  # Slightly more sophisticated
  struct Seq do
    @doc ""
    source: Any
    first: Any
    forced?: Bool
    state: Tuple
  end

  fun map(fn) do
    @doc "Single argument forms of map auto-curry."
    raise error.method("No method matching signature (#{typeof xs}).")
  end

  fun map(fn, xs) do
    @doc "Two-argument forms of map return a collection of the same type as `xs`."
    raise error.method("No method matching signature (#{typeof fn}, #{typeof xs}).")
  end

  fun map(fn: Fun) do
    (coll) -> map(fn, coll)
  end

  fun map(key: Num | Str | Sym) do
    (coll) -> map((x) -> x[key], coll)
  end

  fun map(key: Num | Str | Sym, xs: List) do
    map((x) -> x[key], xs)
  end

  fun map(fn: Fun, xs: List) do
    if xs == [] do
      []
    else
      label loop (fn = fn, xs = xs, off = 0, acc = MutList()) do
        if off == count(xs) do
          to_list(acc)
        else
          loop(fn, xs, off + 1, add_to!(acc, fn(xs[off])))
        end
      end
    end
  end

  fun map(fn: Fun, xs: Str) do
    
  end

  # Examples of effect usage
  fun with_output_file(path: Str, func: Fun) do
    if not file_exists?(path) do
      raise error::file_not_found("file '#{path}' does not exist.")
    else
      control continue do
        var output_file = open(path)
        func(output_file)
      handle exit
        output_file = close(output_file)
      handle enter
        output_file = close(output_file)
      handle error::* (msg)
        print(msg)
        nul
      handle *
        raise * from continue
      end
    end
  end
end