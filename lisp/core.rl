(module core
  "The rascal core module (mostly bootstrapping and macro definitions)."
  (export [val, var, fun, mac, type,
           let,
           cond, case, and, or,
           label,
           throw, catch,
           yield, generator])
  (begin
    ;; Binding syntax.
    (mac let
      [bindings: Vector, & body]
      (fun parse-binding
       ([n: Symbol, i: Any, ns: MutVec, is: MutVec]
        (conj ns n)
        (conj is i))
       ([s: Vector, i: Any, ns: MutVec, is: MutVec]
        (des s ns)
        ()))
      (fun expander
        [b])
      ())
    ;; Branching syntax.
    (mac cond
      "Multiple conditons."
      [& clauses]
      (fun expander
        [&form is ts]
        (let [[i & is] is,
              [t & ts] ts]
          (if (= i 'otherwise)
            (if (done? is)
              t
              (raise :exception/syntax-error $"Dangling clauses in ${&form}."))
            (if (done? is)
              `(if ~i
                 ~t
                 (raise :exception/unhandled-condition ~$"Unhandled condition in ${&form}."))
              `(if ~i
                 ~t
                 ~(expander &form is ts))))))
      (let [[is ts] (lr clauses)]
        (if (!= (len is) (len ts))
          (raise :exception/syntax-error $"Unmatched clauses in ${&form}.")
          (expander &form is ts))))

    (mac case
      "Like `cond`, but the conditional exprssion is always treated as a literal and compared against the first input to the `case` expression."
      [match & clauses]
      (fun expander
        [&form m is ts]
        (let [[i & is] is,
              [t & ts] ts]
          (if (= i 'otherwise)
            (if (done? is)
              t
              (raise :exception/syntax-error $"Dangling clauses in ${&form}."))
            (if (done? is)
              `(if (= ~m '~i)
                 ~t
                 (raise :exception/unhandled-condition ~$"Unhandled condition in ${&form}."))
              `(if (= ~m '~i)
                 ~t
                 ~(expander &form m is ts))))))
      (let [[is ts] (lr clauses)]
        (if (!= (len is) (len ts))
          (raise :exception/syntax-error $"Unmatched clauses in ${&form}.")
          (let [m (sym "match")]
           `(let [~m ~match]
              ~(expander &form m is ts))))))

    (mac and
      "Just `and`."
      ([] true)
      ([x] x)
      ([x & more]
       `(let [x# ~x] (if x# (and ~@more) x#))))

    (mac or
      "Just `or`."
      ([] false)
      ([x] x)
      ([x & more]
       `(let [x# ~x] (if x# x# ~(or ~@more)))))

    ;; Iteration syntax.
    (mac label
      "If the first argument is an argument spec, use `loop` as the default label name."
      [args: Vector, & body]
      `(label loop ~args ~@body))

    (mac label
      "Standard syntax."
      [lname: Symbol, args: Vector, & body]
      (let [[fs is] (lr args)]
        ~((fun ~lname ~fs) ~@body) ~@is))

    (mac label
      "Allow mutual recursion."
      [labels: List, & body]
      (let [[& [lnames largs & lbodies]] labels,
            labels (map #`(fun %1 %2 ~@%3) lnames largs lbodies)]
        `(let []
           ~@labels
           ~@body)))

    (fun lr
      "Split sequence into alternating entries."
      [xs: List]
      (label ((left  [xs al ar]
                (if (done? xs)
                  [(rev al) (rev ar)]
                  (right (rest xs) (conj al (first xs)) ar)))
              (right [xs al ar]
                (if (done? xs)
                  [(rev al) (rev ar)]
                  (left (rest xs) al (conj ar (first xs))))))
        (left xs () ())))

    ;; Effect definitions.
    (mac throw
      "Non-resumable effect for error handling."
      [xt: Symbol, & args]
      `(raise ~(qualify "exception" xs) ~@args))

    (mac catch
      "Handle an exception generated by throw."
      [handlers: List, & body]
      (let [[& [specs & effhs]] handlers,
            [& [xtypes & args]] specs,
            xtypes (map #(qualify "exception" %) xtypes),
            specs (map #`[%1 ~@%2] xtypes args),
            handlers (map #`(~%1 ~@%2) specs effhs)]
        `(handle (~@handlers
                  ([op# & args#] (raise op# & args#)))
           ~@body)))

    (type Generator: Callable
      "A python style coroutine."
      [(name: Final[Symbol]
        [name]
        (sym "generator")),
       (template: Final[Function]
        [&this, template]
        (fun [& args]
          (def! template[:environment] &this[:name] &this)
          (handle (([:yield x]
                    (put &this[:pause] resume)
                    x)
                   ([:return x]
                    (put &this[:finished] true)
                    (put &this[:result] x)
                    x))
          (apply template args)))),
       (pause: Mutable[Control] nul),
       (finished: Mutable[Boolean] false),
       (result: Final[Any] nothing)])

    (fun call
      "Implement `Callable` behavior."
      [g: Generator, & args]
      (cond
        g[:finished] g[:result]
        g[:pause]    (apply g[:pause] args)
        otherwise    (apply g[:template] args)))

    (mac yield
      "Syntactic sugar for raising the `:yield` effect."
      [x]
      `(raise :yield ~x))

    (mac generator
      "Syntactic sugar for creating a generator."
      [fs: Vector, & body]
      `(Generator (fun ~fs ~@body)))

    (mac generator
      "Syntactic sugar for binding a new generator."
      [n: Symbol, fs: Vector, & body]
      `(val ~n (generator ~fs ~@body)))

    (generator range
      "Example generator usage."
      ([e]     (range 0 e 1))
      ([b e]   (range b e 1))
      ([b e s]
       (if (= b e)
         e
         (do (yield b)
           (range (+ b s) e s))))))

